{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"何忒忒","url":"https://vonlyinno.github.io"},"pages":[{"title":"Categories","date":"2018-09-06T04:46:10.059Z","updated":"2018-09-06T04:46:10.059Z","comments":true,"path":"categories/index.html","permalink":"https://vonlyinno.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-09-06T04:46:10.058Z","updated":"2018-09-06T04:46:10.058Z","comments":true,"path":"about/index.html","permalink":"https://vonlyinno.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-09-06T04:46:10.064Z","updated":"2018-09-06T04:46:10.064Z","comments":true,"path":"tags/index.html","permalink":"https://vonlyinno.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mini-yoyoo","slug":"mini-yoyoo","date":"2018-08-17T09:17:02.000Z","updated":"2018-09-06T04:46:10.055Z","comments":true,"path":"2018/08/17/mini-yoyoo/","link":"","permalink":"https://vonlyinno.github.io/2018/08/17/mini-yoyoo/","excerpt":"","text":"封培8天的时间，速成了小程序，只是入门，总结一下遇到的坑，后续完善。 1. 微信小程序没有会话的机制 我们在做邮箱验证的过程中，是后台采用session存储验证码，但是调试过程中session一直为空，且每次请求所携带的sessionid不同。百度之后发现：在微信小程序开发中，由wx.request()发起的每次请求对于服务端来说都是不同的一次会话，微信小程序不会把session信息带回服务端，即对应服务端不同的session，由于项目中使用session保存用户信息所以导致后续请求相当于未登录的情况。 2. 微信上传文件 微信是用api wx.uploadFile, 但我们开发过程中没有申请域名，也不支持https，而这个api是会发起https请求，因此文件一直上传不了。 所幸我们要上传的是图片，最终是将图片转成base64位编码，将编码作为字符串上传。 此处使用了wx-image-uploader 原理大概就是: 将获取到的图片绘制到canvas上，再通过微信的wx.canvasGetImageData,获取canvas数据信息，这里获取到的是buffer，利用upng.js进行编码，输出base64编码。 3. redirectTo &amp; navigateTo 在注册成功后判断登录态，如果登录过就重定向至主页，但是redirectTo在跳转时会有比较长时间的空白，是因为redirectTo会先关闭当前页面，再建立新的页面；而navigateTo则会保留当前页面。","categories":[{"name":"总结","slug":"总结","permalink":"https://vonlyinno.github.io/categories/总结/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://vonlyinno.github.io/tags/小程序/"}]},{"title":"vue-koa-demo入门练手总结","slug":"vue-koa-demo","date":"2018-07-11T08:39:42.000Z","updated":"2018-09-06T04:46:10.057Z","comments":true,"path":"2018/07/11/vue-koa-demo/","link":"","permalink":"https://vonlyinno.github.io/2018/07/11/vue-koa-demo/","excerpt":"","text":"之前看了一些vue和nodejs的教程，但是入门过程中有些问题一直很迷：1.具体的框架怎么构建起来的2.前端是怎么和node通信的3.用vue控制前端路由的目录应该怎么建等… 后来找到全栈开发实战：用Vue2+Koa1开发完整的前后端项目（更新Koa2）这篇文章，跟着写了一遍。不得不说，这位大哥真的太懂我这种初学者需要哪些点了，感谢这位大哥的教程。 步骤就不说了，总结一下跟着做的过程遇到的坑吧，有些可能因为版本更新之类的原因,总之也对版本之间的差别有了更多的了解。 主要版本：12&quot;koa&quot;: &quot;^2.5.1&quot;,&quot;koa-router&quot;: &quot;^7.4.0&quot;, 安装vue-cli安装过程报错123456PS E:\\front\\learn_project&gt; npm install -g vue-clinpm WARN deprecated coffee-script@1.12.7: CoffeeScript on NPM has moved to &quot;coffeescript&quot; (no hyphen)npm ERR! Unexpected end of JSON input while parsing near &apos;...027241519e787343df782&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\hetutu\\AppData\\Roaming\\npm-cache\\_logs\\2018-07-04T11_20_18_301Z-debug.log 解决方法：1npm cache clean --force 使用sequelize-auto在使用sequelize-auto自动生成model的时候，报错12npm install --save sequelize mysqlnpm install -g sequelize-auto 执行1sequelize-auto -o &quot;./schema&quot; -d todolist -h 127.0.0.1 -u root -p 3306 -e mysql -x ht19931007 主要错误信息：123name: &apos;SequelizeConnectionError&apos;, message: &apos;ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client&apos;, 解决方法：1234mysql命令行中执行：use mysql;alter USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;ht19931007&apos;;flush privileges; async/await vs generator原文作者用的都是generator函数（中间件和路由），百度到的koa-router也都是可以用generator的，但路由怎么都挂载不上。看了koa2的文档： 所以需要把原文里的的generator用co处理一下，或者用async/await来写。 this or ctx原文的中间件获取上下文都是用的this,比如：12345const getUserInfo = function* ()&#123; const id = this.params.id; const result = yield user.getUserById(id); this.body = result &#125; 但是我的版本里this获取不到数据，需要用ctx12345const getUserInfo = async function (ctx)&#123; const id = ctx.params.id; const result = await user.getUserById(id); ctx.body = result &#125; axios.delete删除todolist我用的是axios.delete(),比如:1axios.delete(&apos;/api&apos;,&#123;id:1&#125;) 但是后台就是接收不到数据，原来delete第二个参数是 config ，所以要通过 config 里面的 data 来传参：1axios.delete(&apos;/api&apos;,&#123;data:&#123;id:1&#125;&#125;) koa-static &amp; koa-routerkoa-static会拦截请求路径进行处理 如果不是静态文件将会返回http404，两个中间件同时使用时应该先执行router中间件避免请求被static拦截处理。 写在最后入门教程写完，起码明白了之前实习的时候一直很迷的地方：一个目录下的vue和koa是怎么协作的。前端由vue实现单页面，用vue-cli构建的项目本身已经有web-dev-server作为开发服务器了，而使用koa也是实现一个服务器的功能，处理api请求，最后生产环境可以挂载前端build之后的静态资源，把Koa作为一个Vue项目的静态资源服务器,请求就都是同域了。","categories":[{"name":"总结","slug":"总结","permalink":"https://vonlyinno.github.io/categories/总结/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://vonlyinno.github.io/tags/nodejs/"},{"name":"vue","slug":"vue","permalink":"https://vonlyinno.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://vonlyinno.github.io/tags/webpack/"}]},{"title":"网易前端实习生-面经","slug":"interview1","date":"2017-05-12T09:41:51.000Z","updated":"2018-09-06T04:46:10.054Z","comments":true,"path":"2017/05/12/interview1/","link":"","permalink":"https://vonlyinno.github.io/2017/05/12/interview1/","excerpt":"前情提要：网易是会先在线笔试，通过之后会通知你面试的，面试地点是统一在 网易杭州大楼。我投的前端开发工程师，于4月12日面试，一天面完，7-10天出结果，会报销部分路费。中午还可以体验网易的免费午餐，但是肉真的好肥 啊，，，为什么不给天天久坐的程序员提供减脂健身餐(只是我个人小建议，，，)","text":"前情提要：网易是会先在线笔试，通过之后会通知你面试的，面试地点是统一在 网易杭州大楼。我投的前端开发工程师，于4月12日面试，一天面完，7-10天出结果，会报销部分路费。中午还可以体验网易的免费午餐，但是肉真的好肥 啊，，，为什么不给天天久坐的程序员提供减脂健身餐(只是我个人小建议，，，) 正文：这应该是我第一次面对面的面试，还是很紧张的，每轮面试差不多面完5分钟就可以去问有没有下一轮面试了。 一面：一面的面试官很亲切并和善啊，问的还是很基础的： css完全居中 闭包 BFC &amp; IE的BFC 浮动 &amp; 清除浮动 css预处理器 jquery &amp; Angularjs 优势 开发效率 执行效率 怎么沟通之类的总体还是偏css的，会问框架和项目这些 二面：面试官姐姐实在很冷漠啊！我答得也很烂，可能是因为二面是传说中的压力面吧。 轮播图实现 完全居中 js面向对象 &amp; 继承实现 实现下拉框二面问的点不多，但每个点我都卡了很久，有点胡说八道的感觉，确实准备的很不充分，比如轮播的css细节，继承和原型链搞混等。 三面：莫名其妙的来到了三面，因为二面实在面的不好，三面就是hr跟你随便聊一聊，问一下实习时间、家是哪的之类的，还比较轻松吧。 总结其实技术面的话还是很多可以问的点，如果问到准备好的点，就自信的讲清楚，要有条理。如果完全没准备就说不会好了；但是问你怎么实现这种的，就看你的分析能力了，一点点讲清楚你的思路。另外，很多点其实都是根据简历问的，所以可以结合自己的简历、自己做过什么来深挖技术点，学会引导面试官。 更新 4月18号收到了hr小姐姐的电话，问一下关于实习时间问题，后来又问了‘如果有机会转正，是否还会参加秋招’，我说的是‘如果实习完觉得很合适，那么肯定会留下’，hr小姐姐说那就是会参加了。啊，，，此刻感觉我已经告别了我的offer，，，就差一句话，，，心疼我自己，，， 4月26日，更新一下，网易大大发短信说已经顺利通关，正式offer之后会发放！！！哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！不过真的等好久啊！ 最后，谢谢网易大大在我第一次参加现场面试之后，就给了这么大的鼓励，继续努力！","categories":[{"name":"面试","slug":"面试","permalink":"https://vonlyinno.github.io/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://vonlyinno.github.io/tags/面试/"}]},{"title":"剑指offer javascript part1(1-10题)","slug":"sword-to-offer-1","date":"2017-03-29T09:29:25.000Z","updated":"2018-09-06T04:46:10.055Z","comments":true,"path":"2017/03/29/sword-to-offer-1/","link":"","permalink":"https://vonlyinno.github.io/2017/03/29/sword-to-offer-1/","excerpt":"忒忒开始看算法了！ 1. 二维数组中的查找描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码 暴力方式，全部遍历","text":"忒忒开始看算法了！ 1. 二维数组中的查找描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码 暴力方式，全部遍历 12345678910function Find(target, array)&#123; for(var i=0;i&lt;array.length;i++)&#123; for(var j=0;j&lt;array[i].length;j++)&#123; if(array[i][j]==target) return true; &#125; &#125; return false;&#125; 利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col–；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； 1234567891011121314function Find(target, array)&#123; var row = 0; var col = array[0].length-1; while(row&lt;array.length &amp;&amp; col&gt;=0)&#123; if(target == array[row][col])&#123; return true; &#125;else if(target &gt; array[row][col])&#123; row++; &#125;else&#123; col--; &#125; &#125; return false;&#125; 2. 替换空格描述请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码-使用replace（估计题目不是考这个）1234function replaceSpace(str)&#123; return str.replace(/\\s/g,&apos;%20&apos;);&#125; -使用split + join1234function replaceSpace(str)&#123; return str.split(&apos; &apos;).join(&apos;%20&apos;);&#125; 3. 从尾到头打印链表描述输入一个链表，从尾到头打印链表每个节点的值。 代码123456789101112131415/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; // write code here var arr = []; var p = head; while(p)&#123; arr.push(p.val); p = p.next; &#125; return arr.reverse();&#125; 4. 重建二叉树描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码12345678910111213141516171819/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function reConstructBinaryTree(pre, vin)&#123; if(pre.length === 0)return; var node = &#123; val:pre[0] &#125;; for(var i=0;i&lt;vin.length;i++)&#123; if(pre[0] == vin[i])&#123; node.left = reConstructBinaryTree(pre.slice(1,i+1),vin.slice(0,i)); node.right = reConstructBinaryTree(pre.slice(i+1),vin.slice(i+1)); &#125; &#125; return node;&#125; 5. 用两个栈实现队列描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 基本思路：入队时，将元素压入s1。出队时，判断s2是否为空，如不为空，则直接弹出顶元素；如为空，则将s1的元素逐个“倒入”s2，把最后一个元素弹出并出队。 代码123456789101112131415161718192021222324252627282930function Stack()&#123; var arr = []; this.push = function(node)&#123; arr.push(node); return arr; &#125;; this.pop = function()&#123; return arr.pop(); &#125;; this.isEmpty = function()&#123; return arr.length===0; &#125;&#125;//定义两个栈var stack1 = new Stack();var stack2 = new Stack();function push(node)&#123; stack1.push(node);&#125;function pop()&#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop();&#125; 6. 旋转数组的最小数字描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 基本思路：利用二分查找，以最小值为界，左右分为两部分，左右边均不小于于最小值。中间元素若大于最后一个元素，则最小值位于右半边；中间元素若小于最后一个元素，则最小值位于左半边（含中间元素）。 代码1234567891011121314151617function minNumberInRotateArray(rotateArray)&#123; var low = 0; var high = rotateArray.length-1; while(low&lt;high)&#123; var mid = low + Math.floor((high-low)/2); if(rotateArray[mid] &gt; rotateArray[high])&#123; low = mid + 1; &#125;else if(rotateArray[mid] &lt; rotateArray[high])&#123; high = mid; &#125;else&#123; high = high-1; &#125; &#125; return rotateArray[low];&#125; 7. 斐波那契数列描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 分析：经测试，如果用递归的写法会超出时间限制的 代码12345678910function Fibonacci(n)&#123; var aaa = []; aaa[0] = 0; aaa[1] = 1; for(var i=2;i&lt;=n;i++)&#123; aaa[i] = aaa[i-2]+aaa[i-1]; &#125; return aaa[n];&#125; 8. 跳台阶描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 分析对于本题,前提只有 一次 1阶或者2阶的跳法。a. 如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);b. 假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)c. 由a&amp;b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)d. 然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2e. 可以发现最终得出的是一个斐波那契数列：123 | 1, (n=1)f(n) = | 2, (n=2) | f(n-1)+f(n-2) ,(n&gt;2,n为整数) 代码12345678910111213function jumpFloor(number)&#123; var arr = []; if(number === 0)&#123; return -1 &#125; arr.push(1); arr.push(2); for(var i = 2; i &lt; number; i++)&#123; arr.push(arr[i - 1] + arr[i - 2]) &#125; return arr[number - 1]&#125; 9. 变态跳台阶描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路分析1因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级跳1级，剩下n-1级，则剩下跳法是f(n-1)跳2级，剩下n-2级，则剩下跳法是f(n-2)所以f(n)=f(n-1)+f(n-2)+…+f(1)，因为f(n-1)=f(n-2)+f(n-3)+…+f(1)，所以f(n)=2*f(n-1) 代码 1234567891011121314function jumpFloorII(number)&#123; var arr = []; if(number === 0)&#123; return -1 &#125; arr.push(1); arr.push(2); for(var i = 2; i &lt; number; i++)&#123; arr.push(2*arr[i-1]); &#125; return arr[number - 1] &#125; 思路分析2每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况（这个是看的大神解答，感觉略牛逼啊） 1234function jumpFloorII(number)&#123; return number &lt; 0 ? -1 : Math.pow(2,number-1);&#125; 或者更简洁的写法 1234function jumpFloorII(number)&#123; return 1&lt;&lt;--number;&#125; 10. 矩形覆盖描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路分析仍然是斐波那切数列，有以下几种情形：a. number &lt;= 0 直接return 0；b. number = 1大矩形为2*1，只有一种摆放方法，return 1；c. number = 2 大矩形为2*2，有两种摆放方法，return 2；d. number = n 分为两步考虑： 1). 第一次摆放一块 2*1 (竖着)的小矩阵，则摆放方法总共为f(number - 1); 2). 第一次摆放一块1*2(横着)的小矩阵，则摆放方法总共为f(number-2) 因为，摆放了一块1*2的小矩阵，对应下方的1*2摆放方法就确定了，所以为f(number-2) 代码12345678910111213function rectCover(number)&#123; var arr = []; if(number === 0)&#123; return 0 &#125; arr.push(1); arr.push(2); for(var i = 2; i &lt; number; i++)&#123; arr.push(arr[i-1]+arr[i-2]); &#125; return arr[number - 1]&#125; 未完待续…","categories":[{"name":"编程题","slug":"编程题","permalink":"https://vonlyinno.github.io/categories/编程题/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://vonlyinno.github.io/tags/剑指offer/"}]},{"title":"Github pages & Hexo, 博客构建","slug":"create-blog","date":"2017-03-29T09:18:05.000Z","updated":"2018-09-06T04:46:10.054Z","comments":true,"path":"2017/03/29/create-blog/","link":"","permalink":"https://vonlyinno.github.io/2017/03/29/create-blog/","excerpt":"博客已经搭起来一阵了，终于动手写这篇&lt;小白搭建指南&gt;了。懒癌晚期患者实在是懒得折腾服务器来搭建博客，就越省事越好，所以选择了github pages Tips: 2018.07.11 更新: 合并blog源码和编译后代码的github仓库 什么是github pagesGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过 http://username.github.io 来访问你的个人主页。 可以绑定你的域名(但暂时貌似只能绑定一个)。 使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 Tips : [个人感觉] 这个的好处就是项目可以完全留在本地，毕竟这个瞬息万变的时代指不定哪天别人的服务器就shut down了，那我辛辛苦苦码的字不就没了，所以自己保留一份还是比较稳妥的~","text":"博客已经搭起来一阵了，终于动手写这篇&lt;小白搭建指南&gt;了。懒癌晚期患者实在是懒得折腾服务器来搭建博客，就越省事越好，所以选择了github pages Tips: 2018.07.11 更新: 合并blog源码和编译后代码的github仓库 什么是github pagesGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过 http://username.github.io 来访问你的个人主页。 可以绑定你的域名(但暂时貌似只能绑定一个)。 使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 Tips : [个人感觉] 这个的好处就是项目可以完全留在本地，毕竟这个瞬息万变的时代指不定哪天别人的服务器就shut down了，那我辛辛苦苦码的字不就没了，所以自己保留一份还是比较稳妥的~ 基础条件此处假定你已经拥有了一下基础设施： Node.js环境 官网 Git环境 Github账号 创建github仓库 进入Github，点击导航栏的 + 号， 选择New repository 创建repository，名称为你的用户名（比如我的是vonlyinno），其他选项自由选啦 之后的访问域名就是http://vonlyinno.github.io 配置SSH key你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。具体请参考官方教程，介绍的还是比较完整的 Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。以上是官网的介绍，其实就是自己用markdown写了文章，其他的布局、样式、分类、标签等一系列问题都交给Hexo就好了，我们只关心内容就ok。 开始安装 安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1npm install -g hexo-cli 安装好后，也通过查看版本，测试是否安装成功1hexo version 进入刚clone的hexo文件夹，初始化12cd hexohexo init 安装依赖1npm install 生成&amp;启动，可以在http://localhost:4000/ 查看本地效果12hexo g // 或者hexo generatehexo s // 或者hexo server， 安装可能出现的问题： 执行hexo server提示找不到该指令解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：1npm install hexo -server --save 安装好了，来看一下目录结构12345678910├── .deploy //需要部署的文件├── node_modules //Hexo插件├── public //生成的静态网页文件├── scaffolds //模板├── source //博客正文和其他源文件, 404 、favicon 、CNAME| ├── _drafts //草稿| └── _posts //文章├── themes //主题├── _config.yml //全局配置文件└── package.json 部署到github上配置后就可以同步你的文章到github上了。配置deployer，根目录下的全局的_config.yml文件中，请确保每个deployer的缩进长度相同，并且使用空格缩进。1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 安装 hexo-deployer-git1npm install hexo-deployer-git --save 然后在当前目录打开命令行，输入：12hexo ghexo d 或者1hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。 修改主题Hexo的主题确实让博客变美了很多，很多开发者也贡献了自己的主题，可以从官网-主题瞧一瞧看一看，此处也特别鸣谢一下我博客的主题开发者。 下载主题1git clone https://github.com/ppoffice/hexo-theme-icarus.git //主题的地址 配置全局站点文件_config.yml1themes: icarus //主题文件夹名 部署主题，查看效果12hexo ghexo s 主题里有很多配置项，主题太多就不赘述了，还是去看主题文档吧。 写文章这个很简单啊，下面的命令就会在 \\hexo\\source_posts目录下创建一个myblog.md文件1234hexo new myblog```·###### [Hexo常用命令](https://hexo.io/zh-cn/docs/commands.html) hexo help //查看帮助hexo init //初始化目录hexo new “postName” //新建文章hexo new page “pageName” //新建页面hexo generate //生成网页, 可以在public目录查看整个网站的文件hexo server //本地预览,’Ctrl+C’关闭hexo deploy //部署.deploy目录hexo clean //清除缓存, 建议每次执行命令前先清理缓存hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy1234567891011121314##### 写在最后我写markdown最近爱用[简书](http://www.jianshu.com)，可以实时保存+预览，对于md新手很友好，但是发现好像不能预览流程图。最后附上[Hexo官方文档](https://hexo.io/zh-cn/docs/)，多读官方文档，有益身心健康。See you.##### 2018.07.11 更新：合并仓库博客的github仓库管理改过好几遍，由于最初学习不到位，没有考虑过换电脑或者源码迁移备份之类的问题。后来经过更改，是将源码和编译后的blog代码分别放在了两个仓库，可以使用没问题，但是还是放在一个仓库，使用不同分支更好。把步骤甩出来：1.准备：我有两个仓库，源码hexo, blog代码vonlyinno2.将vonlyinno仓库克隆到本地vonlyinno文件夹 git clone git@github.com:vonlyinno/vonlyinno.github.io.git ./vonlyinno1创建hexo分支，并设为默认分支 git checkout -b hexo1可以查看当前已经在hexo分支了 git branch12345678910111213141516171819203.将hexo的内容拷贝进hexo分支。我是先吧hexo给clone下来，再将需要的文件复制进来。&gt; 需要的文件：&gt; * scaffolds&gt; * source&gt; * themes&gt; * .gitignore&gt; * _config.yml&gt; * package.json&gt; * readme.md注意，需要把themes里的.git目录删除。(也可以把hexo分支里原本的编译后的blog文件删掉)我的长这样：hexo分支&lt;img src=&quot;/images/create_blog1.png&quot; alt=&quot;hexo分支&quot;&gt;master分支&lt;img src=&quot;/images/create_blog2.png&quot; alt=&quot;master分支&quot;&gt;4. 提交更新 git add –allgit commit -m ‘合并仓库’git push –set-upstream origin hexo //只用git push的话会提示用这条命令15. 发布 hexo g -d123如果报错的话，先执行hexo clean试一下。6. 更换电脑如果之后更换了电脑，执行clone下这个仓库 npm install`就可以正常使用啦！","categories":[{"name":"技能养成","slug":"技能养成","permalink":"https://vonlyinno.github.io/categories/技能养成/"}],"tags":[{"name":"新技能","slug":"新技能","permalink":"https://vonlyinno.github.io/tags/新技能/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://vonlyinno.github.io/tags/博客搭建/"}]},{"title":"嗨，很高兴遇见你","slug":"nice-to-meet-you","date":"2017-03-07T05:53:16.000Z","updated":"2018-09-06T04:46:10.055Z","comments":true,"path":"2017/03/07/nice-to-meet-you/","link":"","permalink":"https://vonlyinno.github.io/2017/03/07/nice-to-meet-you/","excerpt":"","text":"嗨，从未想过我也会有自己的站点，直到她真的出现在我的浏览器里面。这里可以是我从小白慢慢成长的纪念池，也可以是我碎碎念的废话池，或许就是个文字撒欢的地方。 总之，很高兴遇见你。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://vonlyinno.github.io/categories/碎碎念/"}],"tags":[]}]}